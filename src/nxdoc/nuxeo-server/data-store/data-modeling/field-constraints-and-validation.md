---
title: Field Constraints and Validation
review:
    comment: ''
    date: '2017-12-14'
    status: ok
labels:
    - lts2016-ok
    - link-update
    - schema-component
    - fguillaume
    - lts2017-ok
toc: true
confluence:
    ajs-parent-page-id: '950287'
    ajs-parent-page-title: Content Repository
    ajs-space-key: NXDOC
    ajs-space-name: Nuxeo Platform Developer Documentation
    canonical: Field+Constraints+and+Validation
    canonical_source: 'https://doc.nuxeo.com/display/NXDOC/Field+Constraints+and+Validation'
    page_id: '23363784'
    shortlink: yIBkAQ
    shortlink_source: 'https://doc.nuxeo.com/x/yIBkAQ'
    source_link: /display/NXDOC/Field+Constraints+and+Validation
tree_item_index: 100
history:
    -
        author: Manon Lumeau
        date: '2016-05-10 13:08'
        message: ix Explorer lin
        version: '48'
    -
        author: Solen Guitter
        date: '2015-04-15 12:49'
        message: Add links to explorer.nuxeo.com
        version: '47'
    -
        author: Solen Guitter
        date: '2015-04-10 09:32'
        message: ''
        version: '46'
    -
        author: Thibaud Arguillere
        date: '2015-01-26 19:12'
        message: ''
        version: '45'
    -
        author: Solen Guitter
        date: '2015-01-12 17:06'
        message: 'Moving Extending section in a dedicated how-to '
        version: '44'
    -
        author: Alain Escaffre
        date: '2015-01-05 12:07'
        message: ''
        version: '43'
    -
        author: Alain Escaffre
        date: '2015-01-05 12:06'
        message: ''
        version: '42'
    -
        author: Solen Guitter
        date: '2014-12-29 13:48'
        message: typos and formatting
        version: '41'
    -
        author: Solen Guitter
        date: '2014-12-29 10:23'
        message: Typo
        version: '40'
    -
        author: Solen Guitter
        date: '2014-12-26 15:22'
        message: ''
        version: '39'
    -
        author: Manon Lumeau
        date: '2014-12-23 13:50'
        message: Formatting
        version: '38'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 11:28'
        message: ''
        version: '37'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 10:47'
        message: ''
        version: '36'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 09:53'
        message: ''
        version: '35'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 09:49'
        message: ''
        version: '34'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 09:04'
        message: ''
        version: '33'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 09:03'
        message: ''
        version: '32'
    -
        author: Nicolas Chapurlat
        date: '2014-12-23 09:02'
        message: ''
        version: '31'
    -
        author: Nicolas Chapurlat
        date: '2014-12-22 17:25'
        message: ''
        version: '30'
    -
        author: Nicolas Chapurlat
        date: '2014-12-22 16:49'
        message: ''
        version: '29'
    -
        author: Nicolas Chapurlat
        date: '2014-12-22 15:39'
        message: ''
        version: '28'
    -
        author: Nicolas Chapurlat
        date: '2014-12-22 14:54'
        message: ''
        version: '27'
    -
        author: Nicolas Chapurlat
        date: '2014-12-22 12:25'
        message: ''
        version: '26'
    -
        author: Nicolas Chapurlat
        date: '2014-12-22 11:37'
        message: ''
        version: '25'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 17:39'
        message: ''
        version: '24'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 15:46'
        message: ''
        version: '23'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 15:42'
        message: ''
        version: '22'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 15:36'
        message: ''
        version: '21'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 15:33'
        message: ''
        version: '20'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 15:29'
        message: ''
        version: '19'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 15:06'
        message: ''
        version: '18'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 13:24'
        message: ''
        version: '17'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 13:08'
        message: ''
        version: '16'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 12:58'
        message: ''
        version: '15'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 12:38'
        message: ''
        version: '14'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 12:00'
        message: ''
        version: '13'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 11:33'
        message: ''
        version: '12'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 11:31'
        message: ''
        version: '11'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 11:29'
        message: ''
        version: '10'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 11:19'
        message: ''
        version: '9'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 11:10'
        message: ''
        version: '8'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 10:54'
        message: ''
        version: '7'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 10:48'
        message: ''
        version: '6'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 10:48'
        message: ''
        version: '5'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 10:47'
        message: ''
        version: '4'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 09:52'
        message: ''
        version: '3'
    -
        author: Nicolas Chapurlat
        date: '2014-12-18 09:22'
        message: ''
        version: '2'
    -
        author: Nicolas Chapurlat
        date: '2014-12-17 17:48'
        message: ''
        version: '1'

---
This page explains how to add validation constraints to a document type by using the Nuxeo component [`org.nuxeo.ecm.core.api.DocumentValidationService`](http://explorer.nuxeo.com/nuxeo/site/distribution/latest/viewComponent/org.nuxeo.ecm.core.api.DocumentValidationService).

Document validation is a feature which:

*   Lets you express constraints on Document's fields: field type, format, content, ...
*   Provides the APIs to validate documents
*   Reports the set of violations (localized)
*   Provides the APIs to get constraints on document fields
*   Lets you express that some fields are references to other documents, directory entries, Nuxeo users or Nuxeo groups
*   Provides the APIs to fetch objects referenced by a document field
*   Lets you define references to your own business objects

Document validation does not:

*   Manage cross field validation
*   Manage list field size
*   Manage existing data cleaning

## Concepts

Constraints are defined in schemas, on any field. It is based on XML Schema facets ([W3C - XML Schema - Datatypes](http://www.w3.org/TR/xmlschema-2/)). But Nuxeo does not implement the whole XML Schema specification and Nuxeo adds non-XSD features.

Constraints are loaded by Nuxeo Core as Java objects implementing `org.nuxeo.ecm.core.schema.types.constraints.Constraint`.

{{#> panel type='code' heading='org.nuxeo.ecm.core.schema.types.constraints.Constraint'}}

```java
public interface Constraint {
    boolean validate(Object object);
    String getErrorMessage(Object invalidValue, Locale locale);
    Description getDescription();
    class Description {
        public String getName() {...}
        public Map<String, Serializable> getParameters() {...}
    }
}
```

{{/panel}}

Constraints on a document field are available through the API by calling `org.nuxeo.ecm.core.schema.types.Field.getConstraints()`.

Constraints on a field type are available through the API by calling `org.nuxeo.ecm.core.schema.types.SimpleType.getConstraints()`. Please note that constraints on fields integrate the constraints of the field type.

Documents, document properties or simple values can be validated through Nuxeo service `org.nuxeo.ecm.core.api.validation.DocumentValidationService`.

{{#> panel type='code' heading='org.nuxeo.ecm.core.api.validation.DocumentValidationService'}}

```java
public interface DocumentValidationService {
    ConstraintViolationReport validate(DocumentModel document);
    ConstraintViolationReport validate(Property property);
    ConstraintViolationReport validate(Field field, Object value);
    ...
}
```

{{/panel}}

Validation can be enabled/disabled at different level by means of the extension point [`activations`](http://explorer.nuxeo.com/nuxeo/site/distribution/current/viewContribution/org.nuxeo.ecm.core.api.DocumentValidationService.activations--activations) of the `org.nuxeo.ecm.core.api.DocumentValidationService` component.

## {{> anchor 'contraints-setup'}}Setting up Constraints

Below are the properties of the different constraints that you can set on schema fields.

### Text and Number Format

Name: `PatternConstraint`

Parameters:

*   `Pattern`: the regular expression which constrains the format

Availability: Any XSD simple type derived from datatype `xsd:string`, `xsd:integer`, `xsd:long` or `xsd:decimal` (or alternatives like `xsd:negativeinteger`).

Behavior: This constraint ensures that a field matches a regular expression. `null` value is always valid (use the `NotNullConstraint` in combination).

Examples:

*   An email

    ```xml
    <xs:element name="email">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:pattern value="[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?*" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    ```

*   US Zip Code + 4 digit extension Postal Code

    ```xml
    <xs:simpleType name="zipcodetype">
      <xs:restriction base="xs:integer">
        <xs:pattern value="[0-9]{5}([- /]?[0-9]{4})?" />
      </xs:restriction>
    </xs:simpleType>

    <xs:element name="zipcode" type="zipcodetype" />
    ```

### List of Values

Name: `EnumConstraint`

Parameters:

*   `Values`: A list of possible values for the field

Availability: Any XSD simple type derived from datatype `xsd:string`, `xsd:integer`, `xsd:long` or `xsd:decimal` (or alternatives like `xsd:negativeinteger`).

Behavior: This constraint ensures that the value of a field belongs to a list of values. The `null` value is always valid (use the `NotNullConstraint` in combination).

Example: Preference for the choice of a color

```xml
<xs:element name="color">
  <xs:simpleType>
    <xs:restriction base="xs:string">
      <xs:enumeration value="red" />
      <xs:enumeration value="green" />
      <xs:enumeration value="blue" />
      <xs:enumeration value="black" />
      <xs:enumeration value="white" />
    </xs:restriction>
  </xs:simpleType>
</xs:element>
```

### Length of Text

Name: `LengthConstraint`

Parameters:

*   `Minimum`: The minimum number of characters the field can contain, if specified.
*   `Maximum`: The maximum number of characters the field can contain, if specified.

Availability: Any XSD simple type derived from datatype `xsd:string` (or alternatives like `xsd:name`).

Behavior: This constraint ensures that a field contains a given number of characters. `null` value is always valid (use the `NotNullConstraint` in combination).

{{#> callout type='warning' }}

`LengthConstraint` may alter the database schema when using an SQL backend. If the `minLength` is defined, a varchar with the given length will be created.

{{/callout}}

Examples:

*   A login with a minimal size of 4 characters

    ```xml
    <xs:element name="login">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:minLength value="4" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    ```

*   A credit card code with exactly 15 characters

    ```xml
    <xs:element name="code">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:minLength value="15" />
          <xs:maxLength value="15" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    ```

### Numeric Range

Name: `NumericIntervalConstraint`

Parameters:

*   `Minimum`: The lower bound, if specified.
*   `MinimumInclusive`: `true` if the minimum bound is included, `false` otherwise.
*   `Maximum`: The upper bound, if specified.
*   `MaximumInclusive`: `true` if maximum bound is included, `false` otherwise.

Availability: Any XSD simple type derived from datatype `xsd:integer`, `xsd:long` or `xsd:decimal` (or alternatives like `xsd:negativeinteger`).

Behavior: This constraint ensures that a number is in a given range, `null` value is always valid (use the `NotNullConstraint` in combination).

Examples:

*   A month (Western calendar)

    ```xml
    <xs:element name="month">
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="1" />
          <xs:maxInclusive value="12" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    ```

*   The temperature in the universe (Fahrenheit degrees - above absolute zero)

    ```xml
    <xs:element name="temperature">
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minExclusive value="-459.67" />
        </xs:restriction>
      </xs:simpleType>
    </xs:element>
    ```

### Time Range

Name: `DateIntervalConstraint`

Parameters:

*   `Minimum`: The start date of the time range, if specified.
*   `MinimumInclusive`: `true` if the start date is included, `false` otherwise.
*   `Maximum`: The end date of the time range, if specified.
*   `MaximumInclusive`: `true` if end date is included, `false` otherwise.

Availability: Any XSD simple type derived from datatype `xsd:date` (or alternatives like `xsd:dateTime`).

Behavior: This constraint ensures that a date is in a given time range. `null` value is always valid (use the `NotNullConstraint` in combination).

Example: Any date during 21 century

```xml
<xs:element name="event21century">
  <xs:simpleType>
    <xs:restriction base="xs:date">
      <xs:minInclusive value="2001-01-01" />
      <xs:maxInclusive value="2100-12-31" />
    </xs:restriction>
  </xs:simpleType>
</xs:element>
```

### Mandatory Field

Name: `NotNullConstraint`

Parameters: none

Availability: Any document's field.

Behavior: This constraint ensures that a document's field has a value.

The `NotNullConstraint` Is the only constraint defined on the `<xsd:element>`. Other constraints are defined under `<xsd:simpleType>`. This constraint is also accessible through `Field.getConstraints()` but not through `SimpleType.getConstraints()`.

{{#> callout type='warning' }}

Unlike XML Schema, Nuxeo's fields are optional if nothing was specified. To manage this difference, you have to write the `nillable` attribute from the XSD norm plus another specific to Nuxeo.

The non-standard `nillable` attribute must belong to a specific XML namespace: `http://www.nuxeo.org/ecm/schemas/core/validation/`. Without this namespace, the field will not be mandatory.

{{/callout}}

Example: A mandatory description

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:nxsv="http://www.nuxeo.org/ecm/schemas/core/validation/"
           xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
           targetNamespace="http://www.nuxeo.org/ecm/schemas/example">

  <xs:element name="description" type="xs:string" nillable="false" nxsv:nillable="false" />

</xs:schema>
```

### Constraint Based on the Type

This constraint is automatically added according to XSD datatype on which the type of the document's field is based.

Names: `string`, `long`, `integer`, `double`, `date`, `boolean` and `binary`

Parameters: none

Behavior: This constraint controls the Java types supported by the field. It depends on the XSD datatype on which the element is based.`null` value is always valid (use the `NotNullConstraint` in combination).

<div class="table-scroll"><table class="hover"><tbody><tr><th colspan="1">Constraint name</th><th colspan="1">Supported Java types</th></tr><tr><td colspan="1">`string`</td><td colspan="1">any</td></tr><tr><td colspan="1">`long`</td><td colspan="1">any `java.lang.Number`</td></tr><tr><td colspan="1">`integer`</td><td colspan="1">any `java.lang.Number`</td></tr><tr><td colspan="1">`double`</td><td colspan="1">any `java.lang.Number`</td></tr><tr><td colspan="1">`date`</td><td colspan="1">any `java.util.Date` or `java.util.Calendar`</td></tr><tr><td colspan="1">`boolean`</td><td colspan="1">`java.lang.Boolean`</td></tr><tr><td colspan="1">`binary`</td><td colspan="1">_-_</td></tr></tbody></table></div>

## Setting up References

Below are the properties of the different references you can set on schema fields.

### Reference to Another Document

Name: `documentResolver`

Parameters:

*   `store`: `id` or `path`. If `id`, a document's id is expected. If `path`, a document's path is expected.

Expected value: a concatenation of repository name and id (ex: `default:45678-5678-45678-2346`) or repository name and path (ex: `default:/domain/places/doc`).

Availability: Any XSD simple type derived from datatype `xsd:string` (or alternatives like `xsd:name`).

Behavior: This constraint ensures that a referenced document exists. `null` value is always valid (use the `NotNullConstraint` in combination).

{{#> callout type='warning' }}

Please note that the namespace `http://www.nuxeo.org/ecm/schemas/core/external-references/` is necessary to define a resolver and its parameters.

{{/callout}}

Examples:

*   A reference to another document in a field named "favorite" (note the attribute `ref:store="id"`, the reference will follow the document moves)

    ```xml
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
               xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
               targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
      <xs:element name="favorite">
        <xs:simpleType>
          <xs:restriction base="xs:string" ref:resolver="documentResolver" ref:store="id" />
        </xs:simpleType>
      </xs:element>
    </xs:schema>
    ```

*   A reference to another document in a field named "workspace" (note the attribute `ref:store="path"`, the reference will not follow the document moves)

    ```xml
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
               xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
               targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
      <xs:element name="workspace">
        <xs:simpleType>
          <xs:restriction base="xs:string" ref:resolver="documentResolver" ref:store="path" />
        </xs:simpleType>
      </xs:element>
    </xs:schema>
    ```

### Reference to a Nuxeo User or a Nuxeo Group

Name: `userManagerResolver`

Parameters:

*   `includeUsers`: true if the constraint search for user, false otherwise.
*   `includeGroups`: true if the constraint search for group, false otherwise.

Expected value: a user name prefixed by `"user:"` (`user:Administrator`) or a group name prefixed by `group:` (`group:members`).

Availability: Any XSD simple type derived from datatype `xsd:string` (or alternatives like `xsd:name`).

Behavior: This constraint ensures that a referenced user or group exists. `null` value is always valid (use the `NotNullConstraint` in combination).

{{#> callout type='warning' }}

Please note that the namespace `http://www.nuxeo.org/ecm/schemas/core/external-references/` is necessary to define a resolver and its parameters.

{{/callout}}

Examples:

*   A reference to an author which must be a Nuxeo user (the `ref:type="user"` indicates the field must contain a user - not a group).

    ```xml
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
               xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
               targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
      <xs:element name="author">
        <xs:simpleType>
          <xs:restriction base="xs:string" ref:resolver="userManagerResolver" ref:type="user" />
        </xs:simpleType>
      </xs:element>
    </xs:schema>
    ```

*   A reference to a Nuxeo group (the `ref:type="group"` indicates the field must contain a group - not a user).

    ```xml
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
               xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
               targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
      <xs:element name="group">
        <xs:simpleType>
          <xs:restriction base="xs:string" ref:resolver="userManagerResolver" ref:type="group" />
        </xs:simpleType>
      </xs:element>
    </xs:schema>
    ```

*   A reference to a set of Nuxeo user or Nuxeo group (here, there is no `ref:type` attribute - the field accept user and group).

    ```xml
    <xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
               xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
               targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
      <xs:element name="access">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="principal" minOccurs="0" maxOccurs="unbounded">
              <xs:simpleType>
                <xs:restriction base="xs:string" ref:resolver="userManagerResolver" />
              </xs:simpleType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:schema>
    ```

### Reference to Nuxeo Directory/Vocabulary Entry

Name: `directoryResolver`

Parameters:

*   `directory`: the referenced directory.

Expected value: An id of an directory entry.

Availability: Any XSD simple type derived from datatype `xsd:string` (or alternatives like `xsd:name`).

Behavior: This constraint ensures that a referenced directory entry exists. `null` value is always valid (use the `NotNullConstraint` in combination).

{{#> callout type='warning' }}

Please note that the namespace `http://www.nuxeo.org/ecm/schemas/core/external-references/` is necessary to define a resolver and its parameters.

{{/callout}}

Example: A car brand (the `ref:directory="carBrands"` indicates the field must refer to an entry of the `carBrands` directory).

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
           xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
           targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
  <xs:element name="carBrand">
    <xs:simpleType>
      <xs:restriction base="xs:string" ref:resolver="directoryResolver" ref:directory="carBrands" />
    </xs:simpleType>
  </xs:element>
</xs:schema>
```

## Document Validation APIs

### Explicit Validation

Once you described your data constraints, you can use the validation API to be sure your data are correct.

The validation API provides multiple operations to manage that.

**Get the validation service**

```java
import org.nuxeo.ecm.core.api.validation.DocumentValidationService;
// ...
DocumentValidationService validator = Framework.getService(DocumentValidationService.class);
```

**Validating a full document**

```java
DocumentModel doc = session.createDocumentModel("/", "doc1", "DocumentType");
// update doc ...
DocumentValidationReport report = validator.validate(doc);
```

**Validating the updated fields of a document**

```java
DocumentModel doc = session.getDocument(new PathRef("/doc1"));
// update the existing document
DocumentValidationReport report = validator.validate(doc, true); // the second parameter enable "only dirty" validation
```

**Validating a document property**

```java
DocumentModel doc = session.getDocument(new PathRef("/doc1"));
// update the existing document
DocumentValidationReport report = validator.validate(doc, true); // the second parameter enable "only dirty" validation
```

**Validating data according to a field definition**

```java
SchemaManager schemaManager = Framework.getService(SchemaManager.class);
Schema schema = schemaManager.getSchema("userprofile");
Field field = schema.getField("birthdate");
GregorianCalendar birthdate = new GregorianCalendar(1984, 5, 15);
DocumentValidationReport report = validator.validate(field, birthdate);
```

**Validating data according to a field XPath**

```java
GregorianCalendar birthdate = new GregorianCalendar(1984, 5, 15);
DocumentValidationReport report = validator.validate("userprofile:birthdate", birthdate);
```

**Validating data according to a field XPath (complex fields)**

This feature allows to validate a value according to the definition of a simple field which is a child of a complex types hierarchy.

Given this schema:

```xml
<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:nxv="http://nuxeo.com/schemas/validationSample"
           targetNamespace="http://nuxeo.com/schemas/validationSample"
           xmlns:nxsv="http://www.nuxeo.org/ecm/schemas/core/validation/">
  <xs:element name="users">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="user" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="firstname" nillable="false" nxsv:nillable="false">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:pattern value=".*\S.*" />
                  </xs:restriction>
                </xs:simpleType>
              </xs:element>
            </xs:sequence>
            <xs:attribute name="lastname" use="required">
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:pattern value="[A-Z][a-z '-]+" />
                </xs:restriction>
              </xs:simpleType>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
</xs:schema>
```

You can do:

```java
String firtname = "John";
DocumentValidationReport report = validator.validate("schemprefix:users:user:firstname", firstname);
```

### Automated Validation

Validation can be enable/disable at different level by contributing to the validation service:

```xml
<extension target="org.nuxeo.ecm.core.api.DocumentValidationService" point="activations">
  <validation context="createDocument" activated="true" />
  <validation context="saveDocument" activated="true" />
  <validation context="importDocument" activated="true" />
</extension>
```

{{#> callout type='warning' }}

By default, the validation is fully activated (create, save, import).

{{/callout}}

If activated, validation could throw `DocumentValidationException` while calling:

```java
CoreSession.createDocument(DocumentModel);
CoreSession.createDocument(DocumentModel[]);
CoreSession.saveDocument(DocumentModel);
CoreSession.saveDocuments(DocumentModel[]);
CoreSession.importDocuments(List<DocumentModel>);
```

### Analysing Validation Reports

`DocumentValidationService`'s methods return `DocumentValidationReport`.

When activated, validation will throw a `DocumentValidationException` when creating, saving or importing invalid documents. This exception contains a `DocumentValidationReport`. You can get it by calling `DocumentValidationException.getReport()`.

This report contains all the `ConstraintViolation` met while validating a Document.

You can get a localized error message for each violation by calling `ConstraintViolation.getMessage(Locale)`.

You can also get each violation, the broken constraint, the corresponding invalid value and the place where the violation append.

```java
DocumentValidationReport report = validator.validate(document);
// document constains a list of users with lastname/firtname (lastname and firstname should not be null and must contains non-space characters.
if (report.hasError()) {
    System.out.println(String.format("%s errors found :", report.numberOfErrors()));
    for (ConstraintViolation violation : report.asList()) {
        System.out.println(String.format("- Broken constraint %s", violation.getConstraint().getDescription()));
        System.out.println(String.format("  invalid value : \"%s\"", violation.getInvalidValue()));
        System.out.print("  location: ");
        for (PathNode node : violation.getPath()) {
            System.out.print(node.getField().getName());
            if (node.isListItem()) {
                System.out.print("[" + node.getIndex() + "]");
            }
            System.out.print(":");
        }
        System.out.println();
        System.out.println();
    }
}
// output:
3 errors found :
- Broken constraint NotNullConstraint{}
  invalid value : "null"
  location: vs:users:user[0]:lastname:
- Broken constraint PatternConstraint{Pattern=.*\S.*}
  invalid value : "  "
  location: vs:users:user[0]:firstname:
- Broken constraint NotNullConstraint{}
  invalid value : "null"
  location: vs:users:user[1]:firstname:
```

### Playing with Constraints

Through the APIs, you can get the constraints defined for each fields using:

*   `org.nuxeo.ecm.core.schema.types.Type.getConstraints()`: Will return all constraints defined on type (all except `NotNullConstraint`)
*   `org.nuxeo.ecm.core.schema.types.Field.getConstraints()`: Will return all constraint including `NotNullConstraint` (only field can be defined as `nillable`)

Example: a constraint introspection

```java
for (Schema schema : doc.getDocumentType().getSchemas()) {
    for (Field field : schema.getFields()) {
        constraintIntrospection(field, Arrays.asList(field.getName().getPrefix()));
    }
}

private void constraintIntrospection(Field field, List<String> path) {
    List<String> newPath = new ArrayList<String>(path);
    newPath.add(field.getName().getLocalName());
    System.out.println(StringUtils.join(newPath, ':') + " has constraints: " + field.getConstraints());
    if (field.getType().isListType()) {
        Field listField = ((ListType) field.getType()).getField();
        constraintIntrospection(listField, newPath);
    } else if (field.getType().isComplexType()) {
        for (Field childField : ((ComplexType) field.getType()).getFields()) {
            constraintIntrospection(childField, newPath);
        }
    }
}
// output:
vs:users has constraints: []
vs:users:user has constraints: []
vs:users:user:lastname has constraints: [PatternConstraint{Pattern=[A-Z][a-z '-]+}, NotNullConstraint{}, string{}]
vs:users:user:firstname has constraints: [NotNullConstraint{}, PatternConstraint{Pattern=.*\S.*}, string{}]
```

### Fetching Referenced Entities

When a field is defined as a reference and is associated to a resolver, you can use an `ObjectResolver` to manage the relation between the field and the corresponding object.

Example, a reference to another document:

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:ref="http://www.nuxeo.org/ecm/schemas/core/external-references/"
           xmlns:nxs="http://www.nuxeo.org/ecm/schemas/example"
           targetNamespace="http://www.nuxeo.org/ecm/schemas/example">
  <xs:element name="favorite">
    <xs:simpleType>
      <xs:restriction base="xs:string" ref:resolver="documentResolver" ref:store="id" />
    </xs:simpleType>
  </xs:element>
</xs:schema>
```

To know if a field is a reference:

```java
SchemaManager schemaManager = Framework.getService(SchemaManager.class);
Schema schema = schemaManager.getSchema("schema");
Field field = schema.getField("favorite");
if (field.getType().getObjectResolver() != null) {
  System.out.println("it's a reference to an object");
}
```

To know if a property is a reference:

```java
DocumentModel document = ...;
if (document.getObjectResolver("schema:favorite") != null) {
  System.out.println("it's a reference to an object");
}
// or
Property property = document.getProperty("schema:favorite");
if (property.getObjectResolver() != null) {
  System.out.println("it's a reference to an object");
}
// or finally through the type
if (property.getType().getObjectResolver() != null) {
  System.out.println("it's a reference to an object");
}
```

To get the referenced value:

```java
DocumentModel referenced = document.getObjectResolver("schema:favorite").fetch(DocumentModel.class);
// or
DocumentModel referenced = document.getProperty("schema:favorite").getObjectResolver().fetch(DocumentModel.class);
// both of the 2 previous approach are shortcut for:
Serializable reference = document.getPropertyValue("schema:favorite");
ObjectResolver resolver = document.getProperty("schema:favorite").getType().getObjectResolver();
DocumentModel referenced = resolver.fetch(DocumentModel.class, reference);

```

To set the referenced document:

```java
DocumentModel referenced = ...;
document.getObjectResolver("schema:favorite").setObject(referenced);
// or
document.getProperty("schema:favorite").getObjectResolver().setObject(referenced);
// both of the 2 previous approach are shortcut for:
ObjectResolver resolver = document.getProperty("schema:favorite").getType().getObjectResolver();
Serializable reference = resolver.getReference(referenced);
document.setPropertyValue("schema:favorite", reference);
```

* * *

<div class="row" data-equalizer data-equalize-on="medium"><div class="column medium-6">{{#> panel heading='Related How-Tos'}}

- [How to Customize Document Validation]({{page page='how-to-customize-document-validation'}})
- [How-To Index]({{page page='how-to-index'}})

{{/panel}}</div><div class="column medium-6"></div></div>
