---
title: Contributing an Operation
review:
    comment: ''
    date: '2017-12-14'
    status: ok
labels:
    - lts2016-ok
    - operation
    - automation
    - fdavid
    - excerpt
    - lts2017-ok
toc: true
notes: Documentation page used by the Marketing team. Check with Marketing before deleting or moving.
confluence:
    ajs-parent-page-id: '18451738'
    ajs-parent-page-title: Automation
    ajs-space-key: NXDOC
    ajs-space-name: Nuxeo Platform Developer Documentation
    canonical: Contributing+an+Operation
    canonical_source: 'https://doc.nuxeo.com/display/NXDOC/Contributing+an+Operation'
    page_id: '3342573'
    shortlink: 7QAz
    shortlink_source: 'https://doc.nuxeo.com/x/7QAz'
    source_link: /display/NXDOC/Contributing+an+Operation
tree_item_index: 500
history:
    -
        author: Arnaud Kervern
        date: '2016-08-16 09:46'
        message: ''
        version: '55'
    -
        author: Arnaud Kervern
        date: '2016-08-16 09:33'
        message: ''
        version: '54'
    -
        author: Manon Lumeau
        date: '2016-06-10 12:48'
        message: ''
        version: '53'
    -
        author: Karin Touchie
        date: '2016-02-29 09:02'
        message: ''
        version: '52'
    -
        author: Karin Touchie
        date: '2016-02-16 15:43'
        message: ''
        version: '51'
    -
        author: Thibaud Arguillere
        date: '2015-12-23 10:53'
        message: ''
        version: '50'
    -
        author: Solen Guitter
        date: '2015-01-26 16:47'
        message: link update
        version: '49'
    -
        author: Vladimir Pasquier
        date: '2015-01-05 15:38'
        message: ''
        version: '48'
    -
        author: Vladimir Pasquier
        date: '2015-01-05 15:37'
        message: alias operation
        version: '47'
    -
        author: Solen Guitter
        date: '2014-12-26 14:27'
        message: Add related pages
        version: '46'
    -
        author: Alain Escaffre
        date: '2014-12-19 13:50'
        message: ''
        version: '45'
    -
        author: Alain Escaffre
        date: '2014-12-19 13:49'
        message: ''
        version: '44'
    -
        author: Vladimir Pasquier
        date: '2014-11-25 15:35'
        message: ''
        version: '43'
    -
        author: Alain Escaffre
        date: '2014-11-13 17:42'
        message: ''
        version: '42'
    -
        author: Alain Escaffre
        date: '2014-11-13 17:34'
        message: ''
        version: '41'
    -
        author: Manon Lumeau
        date: '2014-11-06 12:31'
        message: ''
        version: '40'
    -
        author: Solen Guitter
        date: '2014-06-09 16:36'
        message: ''
        version: '39'
    -
        author: Manon Lumeau
        date: '2014-04-30 17:16'
        message: ''
        version: '38'
    -
        author: Manon Lumeau
        date: '2014-04-30 17:14'
        message: ''
        version: '37'
    -
        author: Manon Lumeau
        date: '2014-04-30 17:13'
        message: ''
        version: '36'
    -
        author: Laurent Doguin
        date: '2014-04-29 15:36'
        message: ''
        version: '35'
    -
        author: Laurent Doguin
        date: '2014-04-29 15:29'
        message: ''
        version: '34'
    -
        author: Alain Escaffre
        date: '2014-04-29 14:15'
        message: Adding link to a Codenvy factory
        version: '33'
    -
        author: Solen Guitter
        date: '2014-04-07 11:14'
        message: ''
        version: '32'
    -
        author: Solen Guitter
        date: '2014-04-07 11:14'
        message: ''
        version: '31'
    -
        author: Solen Guitter
        date: '2014-04-07 11:14'
        message: ''
        version: '30'
    -
        author: Alain Escaffre
        date: '2014-04-02 02:44'
        message: ''
        version: '29'
    -
        author: Solen Guitter
        date: '2013-09-20 17:14'
        message: ''
        version: '28'
    -
        author: Solen Guitter
        date: '2013-09-20 17:09'
        message: ''
        version: '27'
    -
        author: Solen Guitter
        date: '2013-07-17 12:03'
        message: ''
        version: '26'
    -
        author: Alain Escaffre
        date: '2013-07-01 13:49'
        message: ''
        version: '25'
    -
        author: Roland Benedetti
        date: '2012-02-24 01:29'
        message: Migrated to Confluence 4.0
        version: '24'
    -
        author: Roland Benedetti
        date: '2012-02-24 01:29'
        message: ''
        version: '23'
    -
        author: Solen Guitter
        date: '2011-11-07 18:25'
        message: corrected links
        version: '22'
    -
        author: Solen Guitter
        date: '2011-08-06 01:02'
        message: ''
        version: '21'
    -
        author: stan
        date: '2011-07-12 15:10'
        message: ''
        version: '20'
    -
        author: stan
        date: '2011-07-12 15:08'
        message: ''
        version: '19'
    -
        author: Alain Escaffre
        date: '2010-08-12 09:12'
        message: ''
        version: '18'
    -
        author: Alain Escaffre
        date: '2010-08-03 14:18'
        message: ''
        version: '17'
    -
        author: StÃ©fane Fermigier
        date: '2010-06-28 08:29'
        message: ''
        version: '16'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 17:01'
        message: ''
        version: '15'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 16:59'
        message: ''
        version: '14'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 16:48'
        message: ''
        version: '13'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 16:15'
        message: ''
        version: '12'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 16:01'
        message: ''
        version: '11'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 15:44'
        message: ''
        version: '10'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 15:28'
        message: ''
        version: '9'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 15:02'
        message: ''
        version: '8'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 14:52'
        message: ''
        version: '7'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 14:47'
        message: ''
        version: '6'
    -
        author: Bogdan Stefanescu
        date: '2010-06-25 13:01'
        message: ''
        version: '5'
    -
        author: Bogdan Stefanescu
        date: '2010-06-24 23:37'
        message: ''
        version: '4'
    -
        author: Bogdan Stefanescu
        date: '2010-06-24 23:37'
        message: ''
        version: '3'
    -
        author: Bogdan Stefanescu
        date: '2010-06-24 23:36'
        message: ''
        version: '2'
    -
        author: Bogdan Stefanescu
        date: '2010-06-24 23:36'
        message: ''
        version: '1'

---

This page provides all the information necessary for implementing an operation and is a must-read for getting a good comprehension of the framework. You should also have a look at [Develop with Nuxeo Platform]({{page page='develop-with-nuxeo-platform'}}) which explain how to use Nuxeo CLI in order to create new operations quickly and easily through the provided wizard.

{{#> callout type='tip' }}

Check out [Nuxeo CLI]({{page page='nuxeo-cli'}}) in order to bootstrap your Operation.

{{/callout}}

## Implementing an Operation

{{! excerpt}}

To implement an operation, you need a Java class with the `@Operation` annotation. An operation class should also provide at least one method to be invoked by the automation service when executing the operation. Mark the method as executable by annotating with `@OperationMethod`.

{{! /excerpt}}

You can have multiple executable methods; one method for each type of input/output object supported by an operation. The correct operation method will automatically be selected if the method argument matches the current input object and the return type matches the input required by the next operation in an automation chain.

The `@OperationMethod` annotation also provides an optional priority attribute that can be used to specify which method is preferred over the other matching methods. This situation (having multiple methods that match an execution) can happen if the input and output types are not strictly matched. For example if the input of a method is a DocumentModel object and the input of another method is a DocumentRef object then both methods have the same input signature for the automation framework because DocumentModel and DocumentRef are objects of the same kind - they represent a Nuxeo Document. When you need to treat different Java objects as the same type of input (or output) you must create a type adapter (see the interface [TypeAdapter](http://community.nuxeo.com/api/nuxeo/latest/javadoc/org/nuxeo/ecm/automation/TypeAdapter.html)) which knows how to convert a given object to another type. Without type adapters, treating different Java objects as the same type of object is not possible.

Operations can include parameterizable variables so that when a user defines an operation chain, they can define values that will be injected in the operation parameters. To declare parameters you must use the `@Param` annotation.

There is one more annotation provided by the automation service: the `@Context` annotation. This annotation can be used to inject execution context objects or Nuxeo Service instances into a running operation.

When registering an automation chain, the chain will be checked to find a path from the first operation to the last one to be sure the chain can be executed at runtime. This means identifying at least one method in each operation that matches the signature of the next operation. If such a path cannot be found, an error is thrown (at registration time). For more details on registering an operation chain, see [Automation Chain]({{page page='automation-chain'}}).

To register your operation, create a Nuxeo XML extension and contribute it to the [`operations` extension point](http://explorer.nuxeo.org/nuxeo/site/distribution/latest/viewExtensionPoint/org.nuxeo.ecm.core.operation.OperationServiceComponent--operations). Example:

```xml
<extension target="org.nuxeo.ecm.core.operation.OperationServiceComponent" point="operations">
  <operation class="org.nuxeo.example.TestOperation" />
</extension>

```

where `org.nuxeo.example.TestOperation` is the class name of your operation (the one annotated with `@Operation)`.

Let's look at the following operation class to see how annotations are used:

```java
import org.nuxeo.ecm.automation.core.Constants;
import org.nuxeo.ecm.automation.core.annotations.Context;
import org.nuxeo.ecm.automation.core.annotations.Operation;
import org.nuxeo.ecm.automation.core.annotations.OperationMethod;
import org.nuxeo.ecm.automation.core.annotations.Param;
import org.nuxeo.ecm.automation.core.util.DocumentHelper;
import org.nuxeo.ecm.automation.core.util.Properties;
import org.nuxeo.ecm.core.api.CoreSession;
import org.nuxeo.ecm.core.api.DocumentModel;
import org.nuxeo.ecm.core.api.DocumentModelList;
import org.nuxeo.ecm.core.api.DocumentRef;
import org.nuxeo.ecm.core.api.DocumentRefList;
import org.nuxeo.ecm.core.api.impl.DocumentModelListImpl;

@Operation(id = CreateDocument.ID, category = Constants.CAT_DOCUMENT, label = "Create", description = "Create a new document in the input folder ...")
public class CreateDocument {

    public final static String ID = "Document.Create";

    @Context
    protected CoreSession session;

    @Param(name = "type")
    protected String type;

    @Param(name = "name", required = false)
    protected String name;

    @Param(name = "properties", required = false)
    protected Properties content;

    @OperationMethod
    public DocumentModel run(DocumentModel doc) throws Exception {
        if (name == null) {
            name = "Untitled";
        }
        DocumentModel newDoc = session.createDocumentModel(
                doc.getPathAsString(), name, type);
        if (content != null) {
            DocumentHelper.setProperties(session, newDoc, content);
        }
        return session.createDocument(newDoc);
    }

    @OperationMethod
    public DocumentModelList run(DocumentModelList docs) throws Exception {
        DocumentModelListImpl result = new DocumentModelListImpl(
                (int) docs.totalSize());
        for (DocumentModel doc : docs) {
            result.add(run(doc));
        }
        return result;
    }

    @OperationMethod
    public DocumentModelList run(DocumentRefList docs) throws Exception {
        DocumentModelListImpl result = new DocumentModelListImpl(
                (int) docs.totalSize());
        for (DocumentRef doc : docs) {
            result.add(run(session.getDocument(doc)));
        }
        return result;
    }
}

```

You can see how `@Context` is used to inject the current CoreSession instance into the session member. It is recommended to use this technique to acquire a CoreSession instead of creating a new session. This way you reuse the same CoreSession used by all the other operations in the chain. You don't need to worry about closing the session &mdash; the automation service will close the session for you, when needed.

You can also use `@Context` to inject any Nuxeo Service or the instance of the `OperationContext` object that represents the current execution context and which holds the execution state, like the last input, the context parameters, the core session, the current principal etc.

The attributes of the `@Operation` annotation are required by operation chain creation tools, like the one in [Nuxeo Studio]({{page space='studio' page='automation'}}), to be able to generate the list of existing operations and some additional operation information, such as its name, a short description on how the operation is working etc. For a complete description of these attributes, look into the annotation Javadoc.

You can see that the operation above provides three operation methods with different signatures:

*   One that takes a Document and returns a Document object
*   One that takes a list of document objects and returns a list of documents
*   One that takes a list of document references and returns a list of documents

Depending on what the input object is when calling this operation, only one of these methods will be used to do the processing. You'll notice that there is no method taking a document reference. This is because the document reference is automatically adapted into a DocumentModel object when needed, thanks to a dedicated TypeAdapter.

The initial input of an operation (or operation chain) execution is provided by the caller (the one that creates the execution context). The Nuxeo Platform provides several execution contexts:

*   A core event listener that executes operations in response to core events
*   An action bean that executes operations in response to the user actions (through the Nuxeo Web Interface)
*   A JAX-RS resource which executes operations in response to REST calls
*   A special listener fired by the workflow service to execute an operation chain

Each of these execution contexts provide the initial input for the chain (or operation) to be executed. For example, the core event listener will use the document that is the source of the event as the initial input. The action bean executor will use the document currently opened in the User Interface.

If no input exists, then **null** will be used as the input. In this case, the first operation in the chain must be a **void** operation.
If you need, you can create your own operation executor. Just look into the existing code for examples (e.g. `org.nuxeo.ecm.automation.jsf.OperationActionBean`).

The code needed to invoke an operation or an operation chain is pretty simple. You need something like this:

```java
CoreSession session = fetchCoreSession();
AutomationService automation = Framework.getService(AutomationService.class);
OperationContext ctx = new OperationContext(session);
ctx.setInput(navigationContext.getCurrentDocument());
try {
  Object result = automation.run(ctx, "the_chain_name");
  // ... do something with the result
} catch (Throwable t) {
  // handle errors
}

```

It gets a little more complicated when you need to set the operation parameters.

Let's take another look at the operation class defined above. You can see that operation parameters are declared as class fields using the `@Param` annotation.

This annotation has several attributes, such as a parameter name, a required flag, a default value if any, a widget type to be used by UI operation chain builders like [Nuxeo Studio]({{page space='studio' page='automation'}}), etc.

The parameter name is important since it is the key you use when defining an operation chain to refer to a specific operation parameter. If the parameter is required then its value must be specified in the operation chain definition otherwise an exception is thrown at runtime. The other parameters are only useful for UI tools that introspect the operations. For example, when building an operation chain in [Nuxeo Studio]({{page space='studio' page='nuxeo-online-services'}}), you need to render each operation parameter using a widget. The default is to use a TextBox if the parameter is a String, a CheckBox if the parameter is a boolean, a ListBox for lists etc. In some situations you may want to override this default mapping. For example, you may want to use a TextArea instead of a TextBox for a string parameter. In that case, you can use the `widget` attribute to specify your desired widget.

## Parameter Injection

Executing an operation is done as follows:

1.  A new operation instance is created (operations are stateless).
2.  The context objects are injected if any `@Context` annotation is present.
3.  Corresponding parameters specified by the execution context are injected into the fields, annotated with `@Param`, and identified using the name attribute of the annotation.
4.  The method matching the execution input and output types is invoked by passing the current input as an argument. (Before invoking the method, the input is adapted if any TypeAdapter was registered for the input type).

Let's look at how parameters are injected into instance fields.

First, the field is identified by using the parameter name. Then, the value to be injected is checked to see if the value type matches the field type. If they don't match, the registered TypeAdapters are consulted for an adapter that knows how to adapt the value type into the field type. If no adapter is found, then an exception is thrown, otherwise the value is adapted and injected into the parameter.
An important case is when EL expressions are used as values. In this case, the expression is evaluated and the result will be used as the value to be injected (and the algorithm of type matching described above is applied to the value returned by the expression).

This means you can use string values for almost all field types because a string adapter exists for almost all parameter types used by operations.

Here's a list of the more commonly used parameter types and the string representation for each (the string representation is important since you should use it when defining operation chains through Nuxeo XML extensions):

<div class="table-scroll">
  <table class="hover">
    <tbody>
      <tr>
        <th>Type</th>
        <th>Java Type</th>
        <th>Known Adapters</th>
        <th>String Representation / Example</th>
      </tr>
      <tr>
        <td>**document**</td>
        <td>`org.nuxeo.ecm.core.api.DocumentModel`</td>
        <td>String, DocumentRef</td>
        <td>
          Document UID or document absolute path. For instance `96bfb9cb-a13d-48a2-9bbd-9341fcf24801` or `/default-domain/workspaces/myws`
        </td>
      </tr>
      <tr>
        <td>**documents**</td>
        <td>`org.nuxeo.ecm.core.api.DocumentModelList`</td>
        <td>DocumentRefList, DocumentModel, DocumentRef</td>
        <td>No String representation exists. Cannot be used as a parameter value in an XML chain descriptor. You should use EL expressions instead.</td>
      </tr>
      <tr>
        <td>**blob**</td>
        <td>`org.nuxeo.ecm.core.api.Blob`</td>
        <td></td>
        <td>No String representation exists. Cannot be used as a parameter value in an XML chain descriptor. You should use EL expressions instead.</td>
      </tr>
      <tr>
        <td>**blobs**</td>
        <td>`org.nuxeo.ecm.automation.core.util.BlobList`</td>
        <td></td>
        <td>No String representation exists. Cannot be used as a parameter value in an XML chain descriptor. You should use EL expressions instead.</td>
      </tr>
      <tr>
        <td>**properties**</td>
        <td>`org.nuxeo.ecm.automation.core.util.Properties`</td>
        <td>String</td>
        <td>A list of key value pairs in Java properties file format.</td>
      </tr>
      <tr>
        <td>**resource**</td>
        <td>`java.net.URL`</td>
        <td>String</td>
        <td></td>
      </tr>
      <tr>
        <td>**script**</td>
        <td>`org.nuxeo.ecm.automation.core.scripting.Expression`</td>
        <td></td>
        <td>
          Use the `expr:` prefix before your EL expression. <br />
          `expr: Document.title` <br />
          For the complete list of scripting objects and functions see [Use of MVEL in Automation Chains]({{page page='use-of-mvel-in-automation-chains'}}).
        </td>
      </tr>
      <tr>
        <td>**date**</td>
        <td>`java.util.Date`</td>
        <td>String, java.util.Calendar</td>
        <td>W3C date format</td>
      </tr>
      <tr>
        <td>**integer**</td>
        <td>`java.lang.Long` or the long primitive type</td>
        <td></td>
        <td>Natural string representation</td>
      </tr>
      <tr>
        <td>**float**</td>
        <td>`java.lang.Double` or the double primitive type</td>
        <td></td>
        <td>Natural string representation</td>
      </tr>
      <tr>
        <td>**boolean**</td>
        <td>`java.lang.Boolean` or the boolean primitive type</td>
        <td></td>
        <td>Natural string representation</td>
      </tr>
      <tr>
        <td>**string**</td>
        <td>`java.lang.String`</td>
        <td></td>
        <td>Already a string</td>
      </tr>
      <tr>
        <td>**stringlist**</td>
        <td>`org.nuxeo.ecm.automation.core.util.StringList`</td>
        <td>String</td>
        <td>
          Comma separated list of strings <br />
          `foo, bar` <br />
          The comma separator can be escaped with the `\` character.
        </td>
      </tr>
    </tbody>
  </table>
</div>

Of course, when defining the parameter values that will be injected into an operation you can either specify static values (as hard coded strings) or an EL expression to compute the actual values at runtime.

## Void Operation Methods

Sometimes operations may not require any input. In this case the operation should use a method with no parameters. Such methods will match any input, so it is not recommended to use more than one void method in the same operation, as you cannot know which method will be selected for execution.

For example, the `Log` operation does not requires an input, since it is only writing in the log:

```java
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.nuxeo.ecm.automation.core.Constants;
import org.nuxeo.ecm.automation.core.annotations.Operation;
import org.nuxeo.ecm.automation.core.annotations.OperationMethod;
import org.nuxeo.ecm.automation.core.annotations.Param;

@Operation(id = LogOperation.ID, category = Constants.CAT_NOTIFICATION, label = "Log", description = "Logging with log4j", aliases = { "LogOperation" })
public class LogOperation {

    public static final String ID = "Log";

    @Param(name = "category", required = false)
    protected String category;

    @Param(name = "message", required = true)
    protected String message;

    @Param(name = "level", required = true, widget = Constants.W_OPTION, values = { "info", "debug", "warn", "error" })
    protected String level = "info";

    @OperationMethod
    public void run() {
        if (category == null) {
            category = "org.nuxeo.ecm.automation.logger";
        }

        Log log = LogFactory.getLog(category);

        if ("debug".equals(level)) {
            log.debug(message);
            return;
        }

        if ("warn".equals(level)) {
            log.warn(message);
            return;
        }

        if ("error".equals(level)) {
            log.error(message);
            return;
        }
        // in any other case, use info log level
        log.info(message);
    }
}

```

Also there are rare cases when you don't want to return anything from an operation. In that case the operation method must use the **void** Java keyword and the result of the operation will be the **null** Java object (in the previous example, the `Log` operation returns no value).

## Aliases

In Automation, you can add aliases for each operation (and create a chain defining itself with operations aliases):

```java
package org.nuxeo.ecm.automation.core.test;

import org.nuxeo.ecm.automation.core.annotations.Operation;
import org.nuxeo.ecm.automation.core.annotations.OperationMethod;
import org.nuxeo.ecm.automation.core.annotations.Param;

@Operation(id = ParamNameWithAliasOperation.ID, aliases = { "aliasOp1",
        "aliasOp2" })
public class ParamNameWithAliasOperation {

    public static final String ID = "OperationWithParamNameAlias";

    @OperationMethod
    public String run() {
        return param;
    }

}

```

And operation parameter aliases as:

```java
import org.nuxeo.ecm.automation.core.annotations.Operation;
import org.nuxeo.ecm.automation.core.annotations.OperationMethod;
import org.nuxeo.ecm.automation.core.annotations.Param;

@Operation(id = ParamNameWithAliasOperation.ID)
public class ParamNameWithAliasOperation {

    public static final String ID = "OperationWithParamNameAlias";

    public static final String ALIAS1 = "alias1";

    public static final String ALIAS2 = "alias2";

    @Param(name = "paramName", alias = { ALIAS1, ALIAS2 })
    protected String param;

    @OperationMethod
    public String run() {
        return param;
    }

}

```

* * *

<div class="row" data-equalizer data-equalize-on="medium"><div class="column medium-6">{{#> panel heading='Related Pages'}}

- [Content Automation Concepts]({{page page='content-automation-concepts'}})
- [Automation How-To Index]({{page page='automation-how-to-index'}})
- [Debugging Automation Chains]({{page page='debugging-automation-chains'}})

{{/panel}}</div><div class="column medium-6">

&nbsp;

</div></div>
